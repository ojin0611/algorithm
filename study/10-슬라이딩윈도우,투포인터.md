# dfs, bfs 풀이

## 백준 2003 : 수들의 합 2

```python
n,m = map(int, input().split())
arr = list(map(int, input().split()))

i, j = 0, 1
ans = 0
while j<=n:
    s = sum(arr[i:j])
    if s>m:
        i +=1 
    elif s<m:
        j +=1
    else:
        ans += 1 
        i += 1
```

## qorwns 11003 : 최솟값 찾기

`start = max(0, i-L+1)` 넣었다가 시간초과났다. 엄청 빡빡하게 시간 맞춰야하는 문제 

```python
from collections import deque
import sys
N, L = map(int, sys.stdin.readline().split())
arr = list(map(int, sys.stdin.readline().split()))


minimum = deque()
ans = [0 for _ in range(N)]
for i in range(N):
    # 이 작업을 통해, minimum에서 arr[i]보다 큰 값이 모두 사라진다. 
    while minimum and arr[i]<minimum[-1][0]:
        minimum.pop()
    
    # 이 작업을 통해, 이미 지나간 index의 값은 버려진다.
    if minimum and minimum[0][1] < i-L+1:
        minimum.popleft()
    
    # 뒤에 하나 추가해줌    
    minimum.append((arr[i], i))
    ans[i] = minimum[0][0]

print(*ans)

```
