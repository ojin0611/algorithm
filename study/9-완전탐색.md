# dfs, bfs 풀이

## 프로그래머스 완전탐색 1. 모의고사


```python
def solution(answers):
    one = [1,2,3,4,5] * (len(answers)//5+1)
    two = [2,1,2,3,2,4,2,5] * (len(answers)//8 + 1)
    three = [3,3,1,1,2,2,4,4,5,5] * (len(answers)//10 + 1)
    
    score = [0,0,0]
    for i, ans in enumerate(answers):
        if one[i]==ans: score[0] += 1
        if two[i]==ans: score[1] += 1
        if three[i]==ans: score[2] += 1
    
    max_score = max(score)
    answer = []
    for i, s in enumerate(score):
        if s == max_score:
            answer.append(i+1)
    return answer
```

## 프로그래머스 완전탐색 2. 소수 찾기


```python
import itertools
def primeList(n):
    # 1 ~ n 중에서 소수를 모두 찾고싶으면
    arr = [False, False] + [True] * n # 0,1은 False
    for i in range(2, int(n**0.5)+1):
        if arr[i]:
            for j in range(i * 2, len(arr), i):
                arr[j] = False
    return arr

def solution(numbers):
    numbers_list = []
    for n in numbers:
        numbers_list.append(n)
    
    answer = 0
    targets = []
    for i in range(1, len(numbers_list)+1):
        for num in itertools.permutations(numbers_list, i):
            target = int(''.join(num))
            targets.append(target)
    
    set_targets = set(targets)
    primes = primeList(max(set_targets))
    for t in set_targets:
        if primes[t]:
            answer += 1
    return answer
```

## 프로그래머스 완전탐색 3. 카펫

```python
def solution(brown, yellow):
    total = brown + yellow
    for i in range(2, int(total**0.5)+1):
        j = total // i # j > i
        if i * j == total:
            if (i-2) * (j-2) == yellow:
                return [j,i]

```